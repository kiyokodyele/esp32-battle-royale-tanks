<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tank 1990 - Spectator View</title>
    <link rel="stylesheet" href="css/style.css">
    <style>
        #connecting-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #connecting-screen h1 {
            font-size: 3em;
            color: #4CAF50;
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
            margin-bottom: 10px;
        }

        #connecting-screen h2 {
            color: #FFD700;
            margin-bottom: 30px;
        }

        #connecting-screen p {
            color: #888;
            font-size: 1.1em;
        }

        .loading-dots::after {
            content: '';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }

        #player-count {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid #444;
        }

        #player-count span {
            color: #4CAF50;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="connecting-screen">
        <h1>TANK 1990</h1>
        <h2>SPECTATOR MODE</h2>
        <p class="loading-dots">Connecting to server</p>
    </div>

    <div id="game-screen" class="screen hidden">
        <div id="game-container">
            <canvas id="game-canvas"></canvas>

            <div id="player-count">
                Players Online: <span id="online-count">0</span>
            </div>

            <div id="scoreboard">
                <h3>SCOREBOARD</h3>
                <div id="scoreboard-list"></div>
            </div>

            <div id="kill-feed"></div>
        </div>
    </div>

    <script>
        class SpectatorView {
            constructor() {
                this.ws = null;
                this.canvas = document.getElementById('game-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.config = null;
                this.gameState = {
                    tanks: [],
                    bullets: [],
                    obstacles: [],
                    powerups: []
                };
                this.explosions = [];
                this.powerupEffects = [];
                this.cameraTarget = null;
                this.cameraX = 0;
                this.cameraY = 0;

                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                this.connect();
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            connect() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                this.ws = new WebSocket(`${protocol}//${window.location.host}`);

                this.ws.onopen = () => {
                    this.ws.send(JSON.stringify({ type: 'spectate' }));
                };

                this.ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    this.handleMessage(data);
                };

                this.ws.onclose = () => {
                    document.getElementById('connection-status').textContent = 'Disconnected';
                    document.getElementById('connection-status').style.color = '#f44336';
                    setTimeout(() => this.connect(), 3000);
                };

                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };
            }

            handleMessage(data) {
                switch (data.type) {
                    case 'spectateJoined':
                        this.config = data.config;
                        this.gameState = {
                            tanks: data.gameState?.tanks || [],
                            bullets: data.gameState?.bullets || [],
                            obstacles: data.gameState?.obstacles || [],
                            powerups: data.gameState?.powerups || []
                        };
                        document.getElementById('connecting-screen').classList.add('hidden');
                        document.getElementById('game-screen').classList.remove('hidden');
                        this.startGameLoop();
                        break;

                    case 'gameState':
                        this.gameState.tanks = data.tanks || [];
                        this.gameState.bullets = data.bullets || [];
                        this.gameState.obstacles = data.obstacles || [];
                        this.gameState.powerups = data.powerups || [];
                        document.getElementById('online-count').textContent =
                            this.gameState.tanks.filter(t => !t.isBot).length;
                        break;

                    case 'playerJoined':
                        this.addKillFeedMessage(`${data.tank.name} joined the battle`, 'powerup');
                        break;

                    case 'playerLeft':
                        const leftTank = this.gameState.tanks.find(t => t.id === data.playerId);
                        if (leftTank) {
                            this.addKillFeedMessage(`${leftTank.name} left the battle`, 'powerup');
                        }
                        break;

                    case 'tankDeath':
                        const victim = this.gameState.tanks.find(t => t.id === data.tankId);
                        const killer = this.gameState.tanks.find(t => t.id === data.killerId);
                        if (victim && killer) {
                            this.addKillFeedMessage(`${killer.name} destroyed ${victim.name}`);
                        } else if (victim && !data.killerId) {
                            this.addKillFeedMessage(`ðŸ’£ ${victim.name} was blown up!`);
                        }
                        break;

                    case 'explosion':
                        this.createExplosionEffect(data.x, data.y, data.radius);
                        break;

                    case 'mysteryExplode':
                        // Show bomb emoji animation + explosion
                        this.createPowerupEffect(data.x, data.y, 'BOMB');
                        this.createExplosionEffect(data.x, data.y, data.radius || 80);
                        const unluckyTank = this.gameState.tanks.find(t => t.id === data.tankId);
                        if (unluckyTank) {
                            this.addKillFeedMessage(`ðŸ’£ ${unluckyTank.name} opened a trap!`);
                        }
                        break;

                    case 'powerupCollect':
                        const collector = this.gameState.tanks.find(t => t.id === data.tankId);
                        if (collector) {
                            if (data.wasMystery) {
                                this.addKillFeedMessage(`ðŸŽ ${collector.name} got ${data.powerupType} from mystery!`, 'powerup');
                            } else {
                                this.addKillFeedMessage(`${collector.name} got ${data.powerupType}`, 'powerup');
                            }
                        }
                        if (data.x !== undefined && data.y !== undefined) {
                            this.createPowerupEffect(data.x, data.y, data.powerupType);
                        }
                        break;

                    case 'scoreboardUpdate':
                        this.updateScoreboard(data.scoreboard);
                        break;

                    case 'scoreboardReset':
                        this.addKillFeedMessage('Scoreboard has been reset!', 'powerup');
                        break;
                }
            }

            updateScoreboard(scoreboard) {
                const list = document.getElementById('scoreboard-list');
                list.innerHTML = '';

                scoreboard.forEach((entry, index) => {
                    const div = document.createElement('div');
                    div.className = 'scoreboard-entry';
                    if (entry.isBot) div.classList.add('bot');

                    div.innerHTML = `
                        <span class="scoreboard-rank">#${index + 1}</span>
                        <span class="scoreboard-name">${entry.name}${entry.isBot ? ' [BOT]' : ''}</span>
                        <span class="scoreboard-score">${entry.score}</span>
                    `;
                    list.appendChild(div);
                });
            }

            addKillFeedMessage(message, type = '') {
                const feed = document.getElementById('kill-feed');
                const div = document.createElement('div');
                div.className = `kill-message ${type}`;
                div.textContent = message;
                feed.appendChild(div);

                setTimeout(() => div.remove(), 5000);
                while (feed.children.length > 5) {
                    feed.removeChild(feed.firstChild);
                }
            }

            createExplosionEffect(x, y, radius) {
                this.explosions.push({
                    x, y, radius,
                    maxRadius: radius,
                    startTime: Date.now()
                });
            }

            createPowerupEffect(x, y, type) {
                const icons = {
                    SPEED: 'âš¡',
                    POWER: 'ðŸ’ª',
                    HEALTH: 'â¤ï¸',
                    RANGE: 'ðŸŽ¯',
                    INVINCIBILITY: 'â­',
                    MYSTERY: 'â“',
                    BOMB: 'ðŸ’£'
                };
                this.powerupEffects.push({
                    x, y,
                    icon: icons[type] || '?',
                    startTime: Date.now()
                });
            }

            startGameLoop() {
                const loop = () => {
                    this.updateCamera();
                    this.render();
                    this.updateExplosions();
                    this.updatePowerupEffects();
                    requestAnimationFrame(loop);
                };
                requestAnimationFrame(loop);
            }

            updateCamera() {
                // Auto-follow: smoothly pan between tanks
                if (this.gameState.tanks.length > 0) {
                    // Switch target every 5 seconds or if current target is gone
                    if (!this.cameraTarget ||
                        !this.gameState.tanks.find(t => t.id === this.cameraTarget) ||
                        Date.now() % 5000 < 50) {
                        const randomIndex = Math.floor(Math.random() * this.gameState.tanks.length);
                        this.cameraTarget = this.gameState.tanks[randomIndex]?.id;
                    }

                    const target = this.gameState.tanks.find(t => t.id === this.cameraTarget);
                    if (target) {
                        // Smooth camera follow
                        this.cameraX += (target.x - this.cameraX) * 0.05;
                        this.cameraY += (target.y - this.cameraY) * 0.05;
                    }
                } else if (this.config) {
                    // No tanks, center on map
                    this.cameraX = this.config.MAP_WIDTH / 2;
                    this.cameraY = this.config.MAP_HEIGHT / 2;
                }
            }

            render() {
                const ctx = this.ctx;
                const config = this.config;

                if (!config) return;

                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Calculate camera offset
                let offsetX = this.canvas.width / 2 - this.cameraX;
                let offsetY = this.canvas.height / 2 - this.cameraY;

                // Clamp to map bounds
                if (this.canvas.width >= config.MAP_WIDTH) {
                    offsetX = (this.canvas.width - config.MAP_WIDTH) / 2;
                } else {
                    offsetX = Math.min(0, Math.max(this.canvas.width - config.MAP_WIDTH, offsetX));
                }

                if (this.canvas.height >= config.MAP_HEIGHT) {
                    offsetY = (this.canvas.height - config.MAP_HEIGHT) / 2;
                } else {
                    offsetY = Math.min(0, Math.max(this.canvas.height - config.MAP_HEIGHT, offsetY));
                }

                ctx.save();
                ctx.translate(offsetX, offsetY);

                this.drawMap();

                if (Array.isArray(this.gameState.obstacles)) {
                    this.gameState.obstacles.forEach(obs => this.drawObstacle(obs));
                }

                if (Array.isArray(this.gameState.powerups)) {
                    this.gameState.powerups.forEach(p => this.drawPowerup(p));
                }

                if (Array.isArray(this.gameState.bullets)) {
                    this.gameState.bullets.forEach(b => this.drawBullet(b));
                }

                if (Array.isArray(this.gameState.tanks)) {
                    this.gameState.tanks.forEach(t => this.drawTank(t));
                }

                this.explosions.forEach(exp => this.drawExplosion(exp));
                this.powerupEffects.forEach(eff => this.drawPowerupEffect(eff));

                ctx.restore();
            }

            drawMap() {
                const ctx = this.ctx;
                const config = this.config;

                ctx.fillStyle = '#2d2d2d';
                ctx.fillRect(0, 0, config.MAP_WIDTH, config.MAP_HEIGHT);

                ctx.strokeStyle = '#3a3a3a';
                ctx.lineWidth = 1;
                const gridSize = 50;

                for (let x = 0; x <= config.MAP_WIDTH; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, config.MAP_HEIGHT);
                    ctx.stroke();
                }

                for (let y = 0; y <= config.MAP_HEIGHT; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(config.MAP_WIDTH, y);
                    ctx.stroke();
                }

                ctx.strokeStyle = '#666';
                ctx.lineWidth = 4;
                ctx.strokeRect(0, 0, config.MAP_WIDTH, config.MAP_HEIGHT);
            }

            drawTank(tank) {
                if (!tank || typeof tank.x !== 'number') return;

                const ctx = this.ctx;
                const size = this.config?.TANK_SIZE || 40;

                // Blinking effect for invincibility (blink every 100ms)
                const isBlinkVisible = Math.floor(Date.now() / 100) % 2 === 0;

                ctx.save();
                ctx.translate(tank.x, tank.y);
                ctx.rotate(tank.angle || 0);

                // Draw invincibility/spawn protection shield with blinking
                if (tank.spawnProtection || tank.invincible) {
                    if (isBlinkVisible) {
                        ctx.beginPath();
                        ctx.arc(0, 0, size / 2 + 10, 0, Math.PI * 2);
                        ctx.strokeStyle = tank.invincible ? '#FFD700' : '#00FFFF';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([5, 5]);
                        ctx.stroke();
                        ctx.setLineDash([]);

                        // Glowing effect
                        ctx.beginPath();
                        ctx.arc(0, 0, size / 2 + 5, 0, Math.PI * 2);
                        ctx.fillStyle = tank.invincible ? 'rgba(255, 215, 0, 0.2)' : 'rgba(0, 255, 255, 0.2)';
                        ctx.fill();
                    }
                }

                // Tank body
                ctx.fillStyle = tank.primaryColor || '#4CAF50';
                ctx.fillRect(-size / 2, -size / 2.5, size, size / 1.25);

                // Tank tracks
                ctx.fillStyle = tank.secondaryColor || '#2E7D32';
                ctx.fillRect(-size / 2, -size / 2.5, size / 6, size / 1.25);
                ctx.fillRect(size / 2 - size / 6, -size / 2.5, size / 6, size / 1.25);

                // Tank turret
                ctx.beginPath();
                ctx.arc(0, 0, size / 4, 0, Math.PI * 2);
                ctx.fill();

                // Tank barrel
                ctx.fillRect(0, -size / 10, size / 2 + 5, size / 5);

                // Avatar in center of tank (on top of turret)
                if (tank.avatarUrl) {
                    ctx.save();
                    ctx.rotate(-tank.angle || 0); // Counter-rotate so avatar stays upright
                    const avatarSize = size / 2.5;
                    const img = new Image();
                    img.src = tank.avatarUrl;
                    ctx.beginPath();
                    ctx.arc(0, 0, avatarSize / 2, 0, Math.PI * 2);
                    ctx.closePath();
                    ctx.clip();
                    try {
                        ctx.drawImage(img, -avatarSize / 2, -avatarSize / 2, avatarSize, avatarSize);
                    } catch (e) {}
                    ctx.restore();
                }

                ctx.restore();

                // Name and HP bar above tank
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(tank.name + (tank.isBot ? ' [BOT]' : ''), tank.x, tank.y - size / 2 - 20);

                const barWidth = 50;
                const barHeight = 6;
                ctx.fillStyle = '#333';
                ctx.fillRect(tank.x - barWidth / 2, tank.y - size / 2 - 12, barWidth, barHeight);

                const hpPercent = (tank.hp || 0) / (tank.maxHp || 100);
                let hpColor = '#4CAF50';
                if (hpPercent < 0.3) hpColor = '#f44336';
                else if (hpPercent < 0.6) hpColor = '#ff9800';

                ctx.fillStyle = hpColor;
                ctx.fillRect(tank.x - barWidth / 2, tank.y - size / 2 - 12, barWidth * hpPercent, barHeight);
            }

            drawBullet(bullet) {
                const ctx = this.ctx;
                const size = 8;

                ctx.save();
                ctx.translate(bullet.x, bullet.y);
                ctx.rotate(bullet.angle || 0);

                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.ellipse(0, 0, size, size / 2, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            drawObstacle(obstacle) {
                const ctx = this.ctx;
                const size = obstacle.size || 40;

                const colors = {
                    TREE: '#228B22',
                    WALL: '#808080',
                    BARREL: '#8B4513',
                    CRATE: '#DEB887'
                };
                const color = colors[obstacle.type] || '#888';

                ctx.save();
                ctx.translate(obstacle.x, obstacle.y);

                switch (obstacle.type) {
                    case 'TREE':
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(-5, -5, 10, 15);
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(0, -10, size / 2, 0, Math.PI * 2);
                        ctx.fill();
                        break;

                    case 'WALL':
                        ctx.fillStyle = color;
                        ctx.fillRect(-size / 2, -size / 2, size, size);
                        ctx.strokeStyle = '#666';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(-size / 2, -size / 2, size, size);
                        break;

                    case 'BARREL':
                        ctx.font = `${size}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('ðŸ’£', 0, 0);
                        break;

                    case 'CRATE':
                        ctx.fillStyle = color;
                        ctx.fillRect(-size / 2, -size / 2, size, size);
                        ctx.strokeStyle = '#8B7355';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(-size / 2, -size / 2);
                        ctx.lineTo(size / 2, size / 2);
                        ctx.moveTo(size / 2, -size / 2);
                        ctx.lineTo(-size / 2, size / 2);
                        ctx.stroke();
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 18px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('?', 0, 0);
                        break;
                }

                ctx.restore();
            }

            drawPowerup(powerup) {
                const ctx = this.ctx;
                const size = powerup.size || 25;

                const data = {
                    SPEED: { color: '#00FFFF', icon: 'âš¡' },
                    POWER: { color: '#FF0000', icon: 'ðŸ’ª' },
                    HEALTH: { color: '#00FF00', icon: 'â¤ï¸' },
                    RANGE: { color: '#FFFF00', icon: 'ðŸŽ¯' },
                    INVINCIBILITY: { color: '#FFD700', icon: 'â­' },
                    MYSTERY: { color: '#9932CC', icon: 'â“' }
                }[powerup.type] || { color: '#fff', icon: '?' };

                ctx.save();
                ctx.translate(powerup.x, powerup.y);

                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
                gradient.addColorStop(0, data.color);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, size * 1.5, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = data.color;
                ctx.beginPath();
                ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(data.icon, 0, 0);

                ctx.restore();
            }

            drawExplosion(explosion) {
                const ctx = this.ctx;
                const elapsed = Date.now() - explosion.startTime;
                const duration = 500;

                if (elapsed > duration) return;

                const progress = elapsed / duration;
                const currentRadius = explosion.maxRadius * (0.5 + progress * 0.5);
                const alpha = 1 - progress;

                ctx.save();
                ctx.globalAlpha = alpha;

                const gradient = ctx.createRadialGradient(
                    explosion.x, explosion.y, 0,
                    explosion.x, explosion.y, currentRadius
                );
                gradient.addColorStop(0, '#FF6600');
                gradient.addColorStop(0.5, '#FF0000');
                gradient.addColorStop(1, 'transparent');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, currentRadius, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }

            updateExplosions() {
                const now = Date.now();
                this.explosions = this.explosions.filter(exp => now - exp.startTime < 500);
            }

            drawPowerupEffect(effect) {
                const ctx = this.ctx;
                const elapsed = Date.now() - effect.startTime;
                const duration = 800;

                if (elapsed > duration) return;

                const progress = elapsed / duration;
                const floatY = effect.y - (progress * 60); // Float upward 60 pixels
                const scale = 1 + progress * 1.5; // Expand from 1x to 2.5x
                const alpha = 1 - progress; // Fade out
                const rotation = progress * Math.PI * 2; // Full rotation

                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.translate(effect.x, floatY);
                ctx.rotate(rotation);
                ctx.scale(scale, scale);

                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(effect.icon, 0, 0);

                ctx.restore();
            }

            updatePowerupEffects() {
                const now = Date.now();
                this.powerupEffects = this.powerupEffects.filter(eff => now - eff.startTime < 800);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            window.spectator = new SpectatorView();
        });
    </script>
</body>
</html>
